<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Staircase Studio üé©</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --panel-bg: rgba(15, 23, 42, 0.9);
            --accent: #38bdf8;
            --accent-warm: #f59e0b;
            --text: #f8fafc;
            --header-h: 60px;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            background-color: var(--bg-color);
            color: var(--text);
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Top Navigation Bar */
        header {
            height: var(--header-h);
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            padding: 0 15px;
            z-index: 1000;
            justify-content: space-between;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .brand h1 {
            font-size: 1.1rem;
            margin: 0;
            color: var(--accent);
            white-space: nowrap;
        }

        /* View Toggle (Relocated to Header) */
        .view-switcher {
            display: flex;
            background: rgba(0, 0, 0, 0.3);
            padding: 4px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .view-btn {
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 600;
            transition: all 0.2s;
            color: rgba(255, 255, 255, 0.6);
        }

        .view-btn.active {
            background: var(--accent);
            color: white;
            box-shadow: 0 2px 8px rgba(56, 189, 248, 0.4);
        }

        #viewport-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #viewport {
            width: 100%;
            height: 100%;
        }

        /* Side Panels (Drawer Style) */
        .panel {
            position: absolute;
            top: 15px;
            bottom: 15px;
            width: 320px;
            background: var(--panel-bg);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            z-index: 500;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .panel-content::-webkit-scrollbar {
            width: 4px;
        }

        .panel-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
        }

        .left-panel {
            left: 15px;
        }

        .right-panel {
            right: 15px;
        }

        .panel.minimised {
            opacity: 0;
            pointer-events: none;
        }

        .left-panel.minimised {
            transform: translateX(-100px);
        }

        .right-panel.minimised {
            transform: translateX(100px);
        }

        /* Floating Toggle Buttons */
        .drawer-toggle {
            position: absolute;
            top: 20px;
            width: 44px;
            height: 44px;
            background: var(--accent);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 600;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            font-size: 1.2rem;
            border: none;
            color: var(--bg-color);
            transition: transform 0.2s;
        }

        .drawer-toggle:active {
            transform: scale(0.9);
        }

        #toggle-left {
            left: 20px;
        }

        #toggle-right {
            right: 20px;
        }

        /* UI Elements */
        h2 {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            margin: 25px 0 12px;
            opacity: 0.5;
            color: var(--accent-warm);
        }

        .control-group {
            margin-bottom: 16px;
        }

        label {
            display: flex;
            font-size: 0.85rem;
            margin-bottom: 8px;
            justify-content: space-between;
        }

        .value-display {
            color: var(--accent);
            font-weight: 700;
        }

        input[type="range"] {
            width: 100%;
            height: 24px;
            accent-color: var(--accent);
            cursor: pointer;
        }

        select,
        input[type="number"] {
            width: 100%;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            color: white;
            font-size: 0.9rem;
        }

        .primary-btn {
            width: 100%;
            background: var(--accent);
            color: var(--bg-color);
            border: none;
            padding: 14px;
            border-radius: 8px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(56, 189, 248, 0.3);
        }

        /* CNC specific */
        .cnc-panel {
            display: none;
        }

        .cnc-panel.visible {
            display: flex;
        }

        #cnc-canvas {
            background: #000;
            width: 100%;
            height: 300px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Loading */
        .selection-panel {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(56, 189, 248, 0.3);
            border-radius: 10px;
            padding: 15px 25px;
            color: white;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .selection-panel h3 {
            margin: 0 0 8px 0;
            color: var(--accent);
        }

        .selection-panel p {
            margin: 4px 0;
            font-size: 0.85rem;
        }

        .category-node {
            margin-bottom: 4px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            overflow: hidden;
        }

        .category-summary {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 8px;
            background: rgba(255, 255, 255, 0.03);
            font-size: 0.8rem;
            cursor: default;
        }

        .icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.9rem;
            padding: 2px 4px;
            opacity: 0.5;
        }

        .icon-btn.active {
            opacity: 1;
        }

        .parts-list {
            padding-left: 16px;
        }

        .part-node {
            padding: 3px 8px;
            cursor: pointer;
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.6);
            border-radius: 4px;
        }

        .part-node:hover {
            background: rgba(56, 189, 248, 0.1);
            color: white;
        }

        .part-node.highlighted {
            background: rgba(56, 189, 248, 0.2);
            color: var(--accent);
        }

        .loading-overlay {
            position: absolute;
            inset: 0;
            background: rgba(15, 23, 42, 0.7);
            backdrop-filter: blur(4px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Mobile Adjustments */
        @media (max-width: 768px) {
            .panel {
                width: calc(100vw - 30px);
            }

            .brand h1 {
                font-size: 0.9rem;
            }

            header {
                padding: 0 10px;
            }

            .view-btn {
                padding: 6px 8px;
                font-size: 0.75rem;
            }
        }

        /* Tree Styles */
        .category-summary {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .parts-list {
            padding-left: 15px;
            margin: 8px 0;
            border-left: 2px solid var(--accent);
        }

        .part-node {
            padding: 8px;
            border-radius: 6px;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .part-node.selected {
            background: rgba(56, 189, 248, 0.2);
            color: var(--accent);
        }

        .selection-panel {
            position: absolute;
            bottom: 20px;
            left: 300px;
            /* Offset past controls panel */
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid #334155;
            border-radius: 8px;
            padding: 15px;
            color: #e2e8f0;
            display: none;
            backdrop-filter: blur(4px);
            z-index: 1000;
            font-family: monospace;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .selection-panel h3 {
            margin: 0 0 10px 0;
            color: #38bdf8;
            font-size: 14px;
        }

        .selection-panel p {
            margin: 5px 0;
            font-size: 12px;
        }

        .highlighted {
            outline: 2px solid #38bdf8;
            background: #1e293b !important;
        }

        .part-node.highlighted {
            background: rgba(56, 189, 248, 0.2);
            border-left: 3px solid #38bdf8;
        }

        .part-item {
            cursor: pointer;
            transition: background 0.2s;
        }

        .part-item:hover {
            background: #1e293b;
        }
    </style>
</head>

<body>
    <header>
        <div class="brand">
            <h1>Staircase Studio <span id="mode-badge"
                    style="font-size: 0.6rem; padding: 2px 6px; background: var(--accent-warm); color: black; border-radius: 4px; margin-left: 5px;">V3</span>
            </h1>
        </div>

        <div class="view-switcher">
            <div class="view-btn active" id="view-3d">3D MODEL</div>
            <div class="view-btn" id="view-cnc">MANUFACTURING</div>
        </div>

        <div style="width: 40px;"></div> <!-- Spacer -->
    </header>

    <div id="viewport-container" style="position: relative; width: 100%; height: calc(100vh - 50px); overflow: hidden;">

        <!-- 3D View Cube Widget -->
        <div id="view-cube"
            style="position: absolute; top: 20px; right: 20px; width: 100px; height: 100px; z-index: 500; cursor: pointer; border-radius: 8px;">
        </div>
        <div id="viewport"></div>

        <button class="drawer-toggle" id="toggle-left" title="Settings">‚öôÔ∏è</button>
        <button class="drawer-toggle" id="toggle-right" title="Parts">üìÅ</button>

        <!-- Left Settings Drawer -->
        <div class="panel left-panel" id="controls-panel">
            <div class="panel-content">
                <div class="control-group">
                    <label>Model Mode</label>
                    <select id="model_type">
                        <option value="volumetric">Volumetric (Concept)</option>
                        <option value="structural" selected>Structural (Precision)</option>
                    </select>
                </div>

                <h2>Geometry</h2>
                <div class="control-group">
                    <label>Width <span class="value-display" id="width-val">800</span></label>
                    <input type="range" id="width" min="600" max="1500" step="50" value="800">
                </div>
                <div class="control-group">
                    <label>Rise <span class="value-display" id="rise-val">220</span></label>
                    <input type="range" id="rise" min="150" max="250" step="5" value="220">
                </div>
                <div class="control-group">
                    <label>Going <span class="value-display" id="going-val">250</span></label>
                    <input type="range" id="going" min="200" max="350" step="5" value="250">
                </div>
                <div class="control-group">
                    <label>Inner Radius <span class="value-display" id="inner_r-val">100</span></label>
                    <input type="range" id="inner_r" min="0" max="500" step="25" value="100">
                </div>
                <div class="control-group">
                    <label>Soffit/Waist <span class="value-display" id="waist-val">150</span></label>
                    <input type="range" id="waist" min="100" max="300" step="5" value="150">
                </div>
                <div class="control-group"
                    style="flex-direction: row; justify-content: space-between; align-items: center;">
                    <label for="unified_soffit" style="margin-bottom: 0;">Unified Soffit (Helical Curve)</label>
                    <input type="checkbox" id="unified_soffit" checked
                        style="width: 20px; height: 20px; cursor: pointer;">
                </div>

                <h2>Flights</h2>
                <div class="control-group">
                    <label>Bottom Steps <span class="value-display" id="s_bottom_steps-val">3</span></label>
                    <input type="range" id="s_bottom_steps" min="0" max="15" step="1" value="3">
                </div>
                <div class="control-group">
                    <label>Winder Steps <span class="value-display" id="winder_steps-val">3</span></label>
                    <input type="range" id="winder_steps" min="2" max="5" step="1" value="3">
                </div>
                <div class="control-group">
                    <label>Top Steps <span class="value-display" id="s_top_steps-val">8</span></label>
                    <input type="range" id="s_top_steps" min="0" max="15" step="1" value="8">
                </div>

                <div id="structural-controls">
                    <h2>Precision Details</h2>
                    <div class="control-group">
                        <label>Tread Overhang <span class="value-display" id="nosing-val">20</span></label>
                        <input type="range" id="nosing" min="0" max="40" step="2" value="20">
                    </div>
                    <div class="control-group">
                        <label>Tread Thickness (mm) <span class="value-display"
                                id="tread_thickness-val">20</span></label>
                        <input type="range" id="tread_thickness" min="10" max="40" step="2" value="20">
                    </div>
                    <div class="control-group">
                        <label>Riser Thickness (mm) <span class="value-display"
                                id="riser_thickness-val">20</span></label>
                        <input type="range" id="riser_thickness" min="10" max="40" step="2" value="20">
                    </div>
                    <div class="control-group">
                        <label>Stringer Width (mm) <span class="value-display" id="stringer_width-val">50</span></label>
                        <input type="range" id="stringer_width" min="30" max="100" step="5" value="50">
                    </div>
                    <div class="control-group">
                        <label>Carriage Width (mm) <span class="value-display" id="carriage_width-val">50</span></label>
                        <input type="range" id="carriage_width" min="30" max="100" step="5" value="50">
                    </div>
                </div>


                <div class="control-group">
                    <label>Explosion Origin</label>
                    <select id="explode_origin"
                        style="width: 100%; padding: 5px; background: rgba(15,23,42,0.8); color: white; border: 1px solid #334155; border-radius: 4px;">
                        <option value="walkline">Walkline (Closest Segment)</option>
                        <option value="center">Geometric Center</option>
                        <option value="bottom">Bottom Start (Long Stringer)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Exploded View <span class="value-display" id="exploded_val">0%</span></label>
                    <input type="range" id="exploded_view" class="slider" min="0" max="100" value="0">
                </div>

                <button id="generate" class="primary-btn">Update Model</button>

                <div id="export-controls" style="margin-top: 20px; display: none;">
                    <h2>Export Assets</h2>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button id="download-glb"
                            style="padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.1); color: white; border-radius: 6px; font-size: 0.7rem;">3D
                            GLB</button>
                        <button id="download-gltf"
                            style="padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.1); color: white; border-radius: 6px; font-size: 0.7rem;">glTF</button>
                        <button id="download-autocad"
                            style="padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.1); color: white; border-radius: 6px; font-size: 0.7rem;">AutoCAD
                            Bundle</button>
                        <button id="download-dxf"
                            style="padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.1); color: white; border-radius: 6px; font-size: 0.7rem;">CNC
                            DXF</button>
                    </div>
                    <button id="download-bom"
                        style="width:100%; margin-top: 8px; padding: 10px; background: #10b981; border: none; color: white; border-radius: 6px; font-size: 0.7rem; cursor: pointer;">Download
                        Takeoff (CSV)</button>
                </div>
            </div>
        </div>

        <!-- Right Object Drawer -->
        <div class="panel right-panel minimised" id="tree-panel">
            <div class="panel-content">
                <h2>Object Registry</h2>
                <div id="tree-content"></div>

                <div id="selection-info"
                    style="display: none; margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <h2>Selection Details</h2>
                    <div id="selection-details"></div>
                </div>
            </div>
        </div>

        <!-- CNC Panel (Overlaying Model) -->
        <div class="panel left-panel cnc-panel" id="cnc-panel">
            <div class="panel-content">
                <h2>Nesting Engine</h2>
                <div class="control-group">
                    <label>Sheet Dimensions (mm)</label>
                    <div style="display: flex; gap: 8px;">
                        <input type="number" id="sheet_width" value="2440">
                        <input type="number" id="sheet_height" value="1220">
                    </div>
                </div>

                <div id="cnc-categories" style="margin: 15px 0;"></div>

                <button id="calculate-nesting" class="primary-btn">Calculate Nesting</button>
                <canvas id="cnc-canvas"></canvas>
                <div id="nesting-stats"></div>
                <button id="download-cnc-dxf" class="primary-btn"
                    style="background: var(--accent-warm); margin-top: 10px;" disabled>Export Nested DXF</button>
            </div>
        </div>

        <div id="loading" class="loading-overlay">
            <div class="spinner"></div>
            <div style="margin-top: 15px; font-weight: 700; color: var(--accent);">GENERATING GEOMETRY...</div>
        </div>

        <div id="selection-panel" class="selection-panel">
            <h3 id="sel-title"></h3>
            <p>Volume: <span id="sel-volume"></span> mm¬≥ (<span id="sel-liters"></span> L)</p>
            <p>Dimensions: <span id="sel-dims"></span> mm</p>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let scene, camera, renderer, controls, model;
        let manifest = null;
        let currentGlbBlob = null;
        const meshMap = new Map();
        const selection = new Set();
        const loader = new GLTFLoader();

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedMeshes = [];
        const selectionColor = new THREE.Color(0x38bdf8);
        const hoverColor = new THREE.Color(0x818cf8);


        let cubeScene, cubeCamera, cubeRenderer, viewCube;
        const cubeRaycaster = new THREE.Raycaster();
        const cubeMouse = new THREE.Vector2();

        init();
        initCube();
        setupUI();
        if (!loadPreset(true)) {
            generateModel();
        }

        // --- NEW FEATURES ---

        async function downloadBOM() {
            try {
                const response = await fetch('/bom');
                if (!response.ok) throw new Error('BOM generation failed');

                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = 'staircase_takeoff.csv';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            } catch (error) {
                console.error('Error downloading BOM:', error);
                alert('Failed to download takeoff. Check server logs.');
            }
        }
        window.downloadBOM = downloadBOM;

        async function downloadExport(format) {
            try {
                let url, filename, method = 'POST', body = JSON.stringify(getConfig());
                const headers = { 'Content-Type': 'application/json' };

                switch (format) {
                    case 'glb':
                        // Re-use the already generated GLB from the last response
                        if (window._lastGlbBase64) {
                            const bin = atob(window._lastGlbBase64);
                            const arr = new Uint8Array(bin.length);
                            for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
                            const blob = new Blob([arr], { type: 'model/gltf-binary' });
                            const a = document.createElement('a');
                            a.href = URL.createObjectURL(blob);
                            a.download = 'staircase.glb';
                            a.click();
                            URL.revokeObjectURL(a.href);
                            return;
                        }
                        alert('Generate a model first.');
                        return;
                    case 'gltf':
                        // Export as glTF (same as GLB but with .gltf)
                        if (window._lastGlbBase64) {
                            const bin = atob(window._lastGlbBase64);
                            const arr = new Uint8Array(bin.length);
                            for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
                            const blob = new Blob([arr], { type: 'model/gltf-binary' });
                            const a = document.createElement('a');
                            a.href = URL.createObjectURL(blob);
                            a.download = 'staircase.gltf';
                            a.click();
                            URL.revokeObjectURL(a.href);
                            return;
                        }
                        alert('Generate a model first.');
                        return;
                    case 'autocad':
                        url = '/export/autocad';
                        filename = 'staircase_autocad.zip';
                        break;
                    case 'dxf':
                        url = '/export/dxf';
                        filename = 'staircase.dxf';
                        break;
                    default:
                        return;
                }

                const response = await fetch(url, { method, headers, body });
                if (!response.ok) throw new Error(`Export failed: ${response.statusText}`);

                const blob = await response.blob();
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                URL.revokeObjectURL(a.href);
                document.body.removeChild(a);
            } catch (error) {
                console.error(`Export error (${format}):`, error);
                alert(`Export failed: ${error.message}`);
            }
        }
        window.downloadExport = downloadExport;

        let originalPositions = new Map();
        let explosionDirections = new Map();

        function updateExplodedView() {
            const expElem = document.getElementById('exploded_view');
            if (!expElem) return;
            const val = parseInt(expElem.value);
            document.getElementById('exploded_val').innerText = val + '%';

            if (!model || meshMap.size === 0) return;

            // Compute and cache directions on first slide
            if (originalPositions.size === 0) {
                // Determine the overall bounding box to find the vertical center (Z axis in three.js if up is Z, or Y if up is Y)
                const box = new THREE.Box3().setFromObject(model);
                const isZUp = (box.max.z - box.min.z) > (box.max.y - box.min.y);

                let overallCenter;
                let walklinePoints = [];
                const originType = document.getElementById('explode_origin')?.value || 'walkline';

                if (originType === 'walkline') {
                    // Extract vertices of the walkline to build a polyline path
                    model.traverse(child => {
                        if (child.isMesh) {
                            // Find the logical parent part
                            let catNode = child;
                            while (catNode && !catNode.name.startsWith("walkline")) {
                                if (catNode.name.startsWith("part_")) {
                                    // Walk up to the category group
                                    catNode = catNode.parent;
                                } else {
                                    catNode = catNode.parent;
                                }
                            }

                            // If this mesh is part of the walkline category, grab its vertices
                            // (We just need a dense sampling of points along the ribbon)
                            if (catNode && catNode.name.startsWith("walkline") || child.material?.name === "walkline") {
                                child.updateMatrixWorld(true);
                                const pos = child.geometry.attributes.position;
                                const idxArr = child.geometry.index;
                                const v = new THREE.Vector3();

                                if (idxArr) {
                                    for (let i = 0; i < idxArr.count; i++) {
                                        v.fromBufferAttribute(pos, idxArr.getX(i));
                                        v.applyMatrix4(child.matrixWorld);
                                        walklinePoints.push(v.clone());
                                    }
                                } else if (pos) {
                                    // Fallback for unindexed geometry
                                    for (let i = 0; i < pos.count; i++) {
                                        v.fromBufferAttribute(pos, i);
                                        v.applyMatrix4(child.matrixWorld);
                                        walklinePoints.push(v.clone());
                                    }
                                }
                            }
                        }
                    });
                    if (walklinePoints.length === 0) {
                        console.warn("Walkline not found in model, falling back to center.");
                        overallCenter = box.getCenter(new THREE.Vector3());
                    }
                } else if (originType === 'bottom') {
                    // Use the bottom starting point (min coords) instead of center. 
                    overallCenter = new THREE.Vector3(box.min.x, box.min.y, box.min.z);
                } else {
                    overallCenter = box.getCenter(new THREE.Vector3());
                }

                // Helper function: Find the absolute closest point on a point cloud / list of vertices
                function getClosestWalklinePoint(target) {
                    if (walklinePoints.length === 0) return overallCenter;
                    let minDistSq = Infinity;
                    let closest = walklinePoints[0];
                    for (let i = 0; i < walklinePoints.length; i++) {
                        const dSq = target.distanceToSquared(walklinePoints[i]);
                        if (dSq < minDistSq) {
                            minDistSq = dSq;
                            closest = walklinePoints[i];
                        }
                    }
                    return closest;
                }

                meshMap.forEach((meshes, idx) => {
                    if (meshes.length === 0) return;

                    // Do not explode the walkline itself‚Äîit must remain the stationary anchor
                    if (meshes[0].material?.name === "walkline" || (meshes[0].parent && meshes[0].parent.name.startsWith("walkline"))) {
                        return;
                    }

                    // 1. Compute a mathematically tight bounding box for the entire semantic part (e.g. Tread 1).
                    // Because the GLTF uses a monolithic shared vertex buffer, we MUST manually check the index buffer
                    // of every leaf mesh belonging to this part, otherwise Three.js evaluates the entire room.
                    const partBox = new THREE.Box3();
                    let isValid = false;

                    meshes.forEach(m => {
                        m.updateMatrixWorld(true);
                        const pos = m.geometry.attributes.position;
                        const idxArr = m.geometry.index;
                        const v = new THREE.Vector3();

                        if (idxArr) {
                            for (let i = 0; i < idxArr.count; i++) {
                                v.fromBufferAttribute(pos, idxArr.getX(i));
                                v.applyMatrix4(m.matrixWorld);
                                partBox.expandByPoint(v);
                                isValid = true;
                            }
                        } else if (pos) {
                            // Unindexed geometry fallback
                            for (let i = 0; i < pos.count; i++) {
                                v.fromBufferAttribute(pos, i);
                                v.applyMatrix4(m.matrixWorld);
                                partBox.expandByPoint(v);
                                isValid = true;
                            }
                        }
                    });

                    if (!isValid) return; // Skip if no geometry found
                    const partCenter = partBox.getCenter(new THREE.Vector3());

                    // Determine the specific origin anchor for this exact part
                    let anchorPoint = overallCenter;
                    if (originType === 'walkline' && walklinePoints.length > 0) {
                        anchorPoint = getClosestWalklinePoint(partCenter);
                    }

                    // 2. Compute Explosion Vector
                    // Use a clean proportional geometric explosion based on distance from the anchor point.
                    const pushDirStr = new THREE.Vector3();
                    const dx = partCenter.x - anchorPoint.x;
                    const dy = partCenter.y - anchorPoint.y;
                    const dz = partCenter.z - anchorPoint.z;

                    pushDirStr.set(dx, dy, dz);

                    // If anchoring to a center/bottom point, apply vertical lifting
                    // If anchoring to the walkline, NO vertical lifting is needed because the walkline already ascends 
                    // alongside the parts naturally, so dz is already local to the step's height!
                    if (originType !== 'walkline') {
                        if (isZUp) {
                            pushDirStr.z *= 1.8;
                        } else {
                            pushDirStr.y *= 1.8;
                        }
                    } else {
                        // For walkline, just amplify the horizontal push so pieces clear the stringers nicely
                        if (isZUp) {
                            pushDirStr.x *= 1.5;
                            pushDirStr.y *= 1.5;
                        } else {
                            pushDirStr.x *= 1.5;
                            pushDirStr.z *= 1.5;
                        }
                    }

                    // 3. Apply this unifying vector to all constituent leaf meshes of this item, 
                    // so the multi-mesh solid item travels through space as one unified block.
                    meshes.forEach(m => {
                        originalPositions.set(m.uuid, m.position.clone());
                        const localPushDir = pushDirStr.clone();
                        if (m.parent) {
                            const parentInverse = m.parent.matrixWorld.clone().invert();
                            localPushDir.transformDirection(parentInverse);
                        }
                        explosionDirections.set(m.uuid, localPushDir);
                    });
                });
            }

            const explosionFactor = val / 50.0; // 0 to 2.0

            meshMap.forEach((meshes, idx) => {
                meshes.forEach(m => {
                    const orig = originalPositions.get(m.uuid);
                    const pushDir = explosionDirections.get(m.uuid);
                    if (orig && pushDir) {
                        m.position.copy(orig).add(pushDir.clone().multiplyScalar(explosionFactor));
                    }
                });
            });
        }
        window.updateExplodedView = updateExplodedView;

        function savePreset(silent = false) {
            const config = getConfig();
            localStorage.setItem('staircase_preset', JSON.stringify(config));
            if (!silent) alert("Preset saved locally! üíæ");
        }

        function loadPreset(silent = false) {
            const saved = localStorage.getItem('staircase_preset');
            if (!saved) {
                if (!silent) alert("No preset found!");
                return false;
            }
            try {
                const config = JSON.parse(saved);
                document.getElementById('model_type').value = config.model_type || 'structural';
                document.getElementById('width').value = config.width;
                document.getElementById('width-val').innerText = config.width;
                document.getElementById('rise').value = config.rise;
                document.getElementById('rise-val').innerText = config.rise;
                document.getElementById('going').value = config.going;
                document.getElementById('going-val').innerText = config.going;
                document.getElementById('inner_r').value = config.inner_r;
                document.getElementById('inner_r-val').innerText = config.inner_r;
                document.getElementById('s_bottom_steps').value = config.s_bottom_steps;
                document.getElementById('s_bottom_steps-val').innerText = config.s_bottom_steps;
                document.getElementById('winder_steps').value = config.winder_steps;
                document.getElementById('winder_steps-val').innerText = config.winder_steps;
                document.getElementById('s_top_steps').value = config.s_top_steps;
                document.getElementById('s_top_steps-val').innerText = config.s_top_steps;
                if (config.waist !== undefined) {
                    document.getElementById('waist').value = config.waist;
                    document.getElementById('waist-val').innerText = config.waist;
                }
                if (config.unified_soffit !== undefined) {
                    document.getElementById('unified_soffit').checked = config.unified_soffit;
                }

                // Precision details
                if (config.nosing !== undefined) {
                    document.getElementById('nosing').value = config.nosing;
                    document.getElementById('nosing-val').innerText = config.nosing;
                }
                if (config.tread_thickness !== undefined) {
                    document.getElementById('tread_thickness').value = config.tread_thickness;
                    document.getElementById('tread_thickness-val').innerText = config.tread_thickness;
                }
                if (config.riser_thickness !== undefined) {
                    document.getElementById('riser_thickness').value = config.riser_thickness;
                    document.getElementById('riser_thickness-val').innerText = config.riser_thickness;
                }
                if (config.stringer_width !== undefined) {
                    document.getElementById('stringer_width').value = config.stringer_width;
                    document.getElementById('stringer_width-val').innerText = config.stringer_width;
                }
                if (config.carriage_width !== undefined) {
                    document.getElementById('carriage_width').value = config.carriage_width;
                    document.getElementById('carriage_width-val').innerText = config.carriage_width;
                }

                // Clear exploded view
                if (document.getElementById('exploded_view')) document.getElementById('exploded_view').value = 0;
                if (document.getElementById('exploded_val')) document.getElementById('exploded_val').innerText = '0%';
                if (model) {
                    meshMap.forEach((meshes, idx) => {
                        meshes.forEach(m => {
                            const orig = originalPositions.get(m.uuid);
                            if (orig) m.position.copy(orig);
                        });
                    });
                }

                // Reset caches for next generation
                originalPositions.clear();
                explosionDirections.clear();

                generateModel();
                return true;
            } catch (e) {
                console.error("Failed to load preset", e);
                return false;
            }
        }
        // --- END NEW FEATURES ---

        // View Widget Logic
        // The old setView function has been removed as it's replaced by the 3D View Cube.

        function setupUI() {
            // Drawer Toggles
            const leftPanel = document.getElementById('controls-panel');
            const rightPanel = document.getElementById('tree-panel');
            const cncPanel = document.getElementById('cnc-panel');

            document.getElementById('toggle-left').onclick = () => {
                leftPanel.classList.toggle('minimised');
                cncPanel.classList.add('minimised');
            };

            document.getElementById('toggle-right').onclick = () => {
                rightPanel.classList.toggle('minimised');
            };

            // View Switcher
            const btn3d = document.getElementById('view-3d');
            const btnCnc = document.getElementById('view-cnc');

            btn3d.onclick = () => {
                btn3d.classList.add('active');
                btnCnc.classList.remove('active');
                cncPanel.style.display = 'none';
                leftPanel.style.display = 'flex';
                rightPanel.style.display = 'flex';
            };

            btnCnc.onclick = () => {
                btnCnc.classList.add('active');
                btn3d.classList.remove('active');
                cncPanel.style.display = 'flex';
                leftPanel.style.display = 'none';
                rightPanel.style.display = 'none';
                populateCncCategories();
            };

            // Slider listeners (skip the explode slider ‚Äî it has its own handler)
            document.querySelectorAll('input[type="range"]').forEach(el => {
                if (el.id === 'exploded_view') return; // preserve updateExplodedView()
                el.oninput = () => {
                    const display = document.getElementById(el.id + '-val');
                    if (display) display.textContent = el.value;
                };
            });

            // Explode slider ‚Äî attach handler programmatically (module scope blocks inline oninput)
            const explodeSlider = document.getElementById('exploded_view');
            if (explodeSlider) {
                explodeSlider.addEventListener('input', updateExplodedView);
            }

            // Export button handlers
            document.getElementById('download-glb').onclick = () => downloadExport('glb');
            document.getElementById('download-gltf').onclick = () => downloadExport('gltf');
            document.getElementById('download-autocad').onclick = () => downloadExport('autocad');
            document.getElementById('download-dxf').onclick = () => downloadExport('dxf');
            document.getElementById('download-bom').onclick = () => downloadBOM();

            document.getElementById('download-cnc-dxf').onclick = async () => {
                const cats = Array.from(document.querySelectorAll('#cnc-categories input:checked')).map(i => i.value);
                if (cats.length === 0) {
                    alert("Select at least one nested category to export.");
                    return;
                }
                const body = JSON.stringify({
                    config: getConfig(),
                    categories: cats,
                    sheet_width: parseFloat(document.getElementById('sheet_width').value),
                    sheet_height: parseFloat(document.getElementById('sheet_height').value)
                });

                try {
                    document.getElementById('download-cnc-dxf').innerText = "Exporting...";
                    const response = await fetch('/cnc/export-dxf', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: body
                    });
                    if (!response.ok) throw new Error(`Export failed: ${response.statusText}`);

                    const blob = await response.blob();
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = 'cnc_nested_layout.dxf';
                    document.body.appendChild(a);
                    a.click();
                    URL.revokeObjectURL(a.href);
                    document.body.removeChild(a);
                } catch (error) {
                    console.error('CNC DXF export error:', error);
                    alert(`Export failed: ${error.message}`);
                } finally {
                    document.getElementById('download-cnc-dxf').innerText = "Export Nested DXF";
                }
            };
            // Auto-generate on any parameter change
            document.querySelectorAll('#controls-panel input').forEach(el => {
                if (el.id !== 'exploded_view' && el.id !== 'explode_origin') {
                    el.addEventListener('change', () => {
                        // Debounce slightly to prevent lag on sliders
                        clearTimeout(window._genTimeout);
                        window._genTimeout = setTimeout(generateModel, 300);
                    });
                }
            });

            const originSelect = document.getElementById('explode_origin');
            if (originSelect) {
                originSelect.addEventListener('change', () => {
                    // Reset positions and clear cache so next explosion recalculates vectors
                    const expElem = document.getElementById('exploded_view');
                    expElem.value = 0;
                    document.getElementById('exploded_val').innerText = '0%';
                    if (model && meshMap.size > 0) {
                        meshMap.forEach((meshes) => {
                            meshes.forEach(m => {
                                const orig = originalPositions.get(m.uuid);
                                if (orig) m.position.copy(orig);
                            });
                        });
                    }
                    originalPositions.clear();
                    explosionDirections.clear();
                });
            }

            document.getElementById('calculate-nesting').onclick = runNesting;
        }

        function getConfig() {
            return {
                model_type: document.getElementById('model_type').value,
                width: parseFloat(document.getElementById('width').value),
                rise: parseFloat(document.getElementById('rise').value),
                going: parseFloat(document.getElementById('going').value),
                inner_r: parseFloat(document.getElementById('inner_r').value),
                s_bottom_steps: parseInt(document.getElementById('s_bottom_steps').value),
                winder_steps: parseInt(document.getElementById('winder_steps').value),
                s_top_steps: parseInt(document.getElementById('s_top_steps').value),
                nosing: parseFloat(document.getElementById('nosing').value),
                tread_thickness: parseFloat(document.getElementById('tread_thickness').value),
                riser_thickness: parseFloat(document.getElementById('riser_thickness').value),
                stringer_width: parseFloat(document.getElementById('stringer_width').value),
                carriage_width: parseFloat(document.getElementById('carriage_width').value),
                unified_soffit: document.getElementById('unified_soffit').checked,
                extend_top_flight: 300,
                waist: parseFloat(document.getElementById('waist').value)
            };
        }

        async function generateModel() {
            const loading = document.getElementById('loading');
            loading.style.display = 'flex';

            // Auto-save preset on generate
            savePreset(true);

            try {
                const response = await fetch('/generate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(getConfig())
                });

                const data = await response.json();
                manifest = data.manifest;
                window._lastGlbBase64 = data.glb;
                window._categoryStyles = data.styles || {};

                const binaryString = atob(data.glb);
                const len = binaryString.length;
                const glbBytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    glbBytes[i] = binaryString.charCodeAt(i);
                }
                const url = URL.createObjectURL(new Blob([glbBytes], { type: 'model/gltf-binary' }));

                loader.load(url, (gltf) => {
                    if (model) scene.remove(model);
                    model = gltf.scene;

                    meshMap.clear();
                    model.traverse(child => {
                        if (child.isMesh) {
                            let idx = -1;
                            let curr = child;
                            while (curr) {
                                if (curr.name.startsWith("part_")) {
                                    idx = parseInt(curr.name.split("_")[1]);
                                    break;
                                }
                                curr = curr.parent;
                            }
                            if (idx >= 0) {
                                if (!meshMap.has(idx)) meshMap.set(idx, []);
                                meshMap.get(idx).push(child);
                            }
                            child.userData.originalMaterial = child.material;
                        }
                    });

                    scene.add(model);

                    // Auto-center and fit camera to model
                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());

                    // Move model to center origin
                    model.position.x += (model.position.x - center.x);
                    model.position.y += (model.position.y - center.y);
                    model.position.z += (model.position.z - center.z);

                    // Update camera position to fit the model
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = camera.fov * (Math.PI / 180);
                    let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                    cameraZ *= 1.5; // zoom out a little

                    camera.position.set(cameraZ, cameraZ, cameraZ);
                    camera.lookAt(0, 0, 0);
                    controls.target.set(0, 0, 0);
                    controls.update();

                    document.getElementById('export-controls').style.display = 'block';
                    originalPositions.clear(); // Reset explode state for new model
                    if (document.getElementById('exploded_view')) {
                        document.getElementById('exploded_view').value = 0;
                        document.getElementById('exploded_val').innerText = '0%';
                    }
                    renderObjectTree();
                    loading.style.display = 'none';
                });
            } catch (err) {
                alert("Generation Error: " + err.message);
                loading.style.display = 'none';
            }
        }

        function renderObjectTree() {
            const container = document.getElementById('tree-content');
            container.innerHTML = '';
            if (!manifest || !manifest.categories) return;

            // Get styles from server response
            const styles = window._categoryStyles || {};

            manifest.categories.forEach(cat => {
                const catNode = document.createElement('div');
                catNode.className = 'category-node';

                // Default color from styles or fallback
                const style = styles[cat.name] || {};
                const defaultColor = style.color
                    ? `#${style.color.map(c => Math.round(c * 255).toString(16).padStart(2, '0')).join('')}`
                    : '#888888';
                const defaultOpacity = style.opacity !== undefined ? style.opacity : 1.0;

                // Category header with controls
                const header = document.createElement('div');
                header.className = 'category-summary';
                header.innerHTML = `
                    <span class="cat-toggle" style="cursor:pointer;">‚ñ∂</span>
                    <strong>${cat.name}</strong> (${cat.parts.length})
                    <span style="flex:1;"></span>
                    <button class="icon-btn active" data-cat="${cat.name}" title="Toggle visibility">üëÅ</button>
                    <input type="color" value="${defaultColor}" data-cat="${cat.name}" title="Category colour" style="width:24px;height:24px;border:none;background:none;cursor:pointer;">
                    <input type="range" min="0" max="100" value="${Math.round(defaultOpacity * 100)}" data-cat="${cat.name}" title="Opacity" style="width:60px;">
                `;
                catNode.appendChild(header);

                // Toggle expand/collapse
                const toggleArrow = header.querySelector('.cat-toggle');
                const partsList = document.createElement('div');
                partsList.className = 'parts-list';
                partsList.style.display = 'none';

                toggleArrow.onclick = () => {
                    const open = partsList.style.display !== 'none';
                    partsList.style.display = open ? 'none' : 'block';
                    toggleArrow.textContent = open ? '‚ñ∂' : '‚ñº';
                };

                // Visibility toggle
                header.querySelector('.icon-btn').onclick = function () {
                    const visible = this.classList.toggle('active');
                    this.textContent = visible ? 'üëÅ' : 'üö´';
                    cat.parts.forEach(p => {
                        const meshes = meshMap.get(p.mesh_index);
                        if (meshes) meshes.forEach(m => m.visible = visible);
                    });
                };

                // Color picker
                header.querySelector('input[type="color"]').oninput = function () {
                    const color = new THREE.Color(this.value);
                    cat.parts.forEach(p => {
                        const meshes = meshMap.get(p.mesh_index);
                        if (meshes) meshes.forEach(m => {
                            m.material = m.material.clone();
                            m.material.color = color;
                            m.userData.originalMaterial = m.material;
                        });
                    });
                };

                // Opacity slider
                header.querySelector('input[type="range"]').oninput = function () {
                    const opacity = parseInt(this.value) / 100;
                    cat.parts.forEach(p => {
                        const meshes = meshMap.get(p.mesh_index);
                        if (meshes) meshes.forEach(m => {
                            m.material = m.material.clone();
                            m.material.opacity = opacity;
                            m.material.transparent = opacity < 1.0;
                            m.material.depthWrite = opacity >= 1.0;
                            m.userData.originalMaterial = m.material;
                        });
                    });
                };

                // Individual parts
                cat.parts.forEach(p => {
                    const pnode = document.createElement('div');
                    pnode.className = 'part-node';
                    pnode.id = `tree-part-${p.mesh_index}`;
                    pnode.textContent = p.name;
                    pnode.onclick = () => selectPart(p.mesh_index);
                    partsList.appendChild(pnode);
                });
                catNode.appendChild(partsList);
                container.appendChild(catNode);
            });
        }



        function populateCncCategories() {
            const container = document.getElementById('cnc-categories');
            if (!manifest || !manifest.categories) return;

            // Check if we have thickness data
            const hasThickness = manifest.categories.length > 0 && typeof manifest.categories[0].thickness !== 'undefined';

            if (hasThickness) {
                container.innerHTML = '<h2 style="margin-bottom:0;">Sheet Content</h2><p style="font-size:0.75rem; color:#94a3b8; margin-top:5px; margin-bottom:15px;">All parts on a sheet must share the same material thickness.</p>';

                // Group by thickness
                const byThickness = {};
                manifest.categories.forEach(cat => {
                    const t = cat.thickness || 0;
                    if (!byThickness[t]) byThickness[t] = [];
                    byThickness[t].push(cat.name);
                });

                Object.entries(byThickness).forEach(([thickness, cats]) => {
                    container.innerHTML += `<div style="font-size:12px; color:#38bdf8; margin-top:12px; margin-bottom:6px; font-weight:bold;">${thickness}mm THICKNESS</div>`;
                    cats.forEach(name => {
                        container.innerHTML += `
                            <div style="display:flex; gap:10px; margin-bottom:5px;">
                                <input type="checkbox" class="cnc-cat-checkbox" data-thickness="${thickness}" value="${name}"> ${name}
                            </div>
                        `;
                    });
                });

                setTimeout(() => {
                    const checkboxes = document.querySelectorAll('.cnc-cat-checkbox');

                    // Pre-select the first thickness group natively
                    if (checkboxes.length > 0) {
                        const firstThick = checkboxes[0].getAttribute('data-thickness');
                        checkboxes.forEach(c => {
                            if (c.getAttribute('data-thickness') === firstThick) {
                                c.checked = true;
                            } else {
                                c.disabled = true;
                            }
                        });
                    }

                    checkboxes.forEach(cb => {
                        cb.addEventListener('change', () => {
                            const checkedArr = Array.from(checkboxes).filter(c => c.checked);
                            const selectedThickness = checkedArr.length > 0 ? checkedArr[0].getAttribute('data-thickness') : null;

                            checkboxes.forEach(c => {
                                if (selectedThickness) {
                                    if (c.getAttribute('data-thickness') !== selectedThickness) {
                                        c.disabled = true;
                                        c.checked = false;
                                    } else {
                                        c.disabled = false;
                                    }
                                } else {
                                    // None selected, everything possible
                                    c.disabled = false;
                                }
                            });
                        });
                    });
                }, 50);

            } else {
                container.innerHTML = '<h2>Sheet Content</h2>';
                manifest.categories.forEach(cat => {
                    let catName = typeof cat === 'object' ? cat.name : cat;
                    container.innerHTML += `
                        <div style="display:flex; gap:10px; margin-bottom:5px;">
                            <input type="checkbox" value="${catName}" checked> ${catName}
                        </div>
                    `;
                });
            }
        }

        async function runNesting() {
            const cats = Array.from(document.querySelectorAll('#cnc-categories input:checked')).map(i => i.value);
            const res = await fetch('/cnc/nest', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    config: getConfig(),
                    categories: cats,
                    sheet_width: parseFloat(document.getElementById('sheet_width').value),
                    sheet_height: parseFloat(document.getElementById('sheet_height').value)
                })
            });
            const data = await res.json();
            drawNesting(data);
        }

        function drawNesting(result) {
            const canvas = document.getElementById('cnc-canvas');
            const ctx = canvas.getContext('2d');

            // Set internal resolution based on content
            const numSheets = result.sheet_count || 1;
            const sheetW = 2440;
            const sheetH = 1220;

            canvas.width = canvas.offsetWidth * 2;
            const scale = canvas.width / (sheetW + 100);
            canvas.height = (sheetH * scale + 100) * numSheets;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            Object.entries(result.sheets).forEach(([idx, sheetData]) => {
                const yOff = parseInt(idx) * (sheetH * scale + 80) + 60;

                // Draw Sheet Border
                ctx.strokeStyle = '#38bdf8';
                ctx.lineWidth = 4;
                ctx.strokeRect(20, yOff, sheetW * scale, sheetH * scale);
                ctx.fillStyle = 'rgba(255,255,255,0.02)';
                ctx.fillRect(20, yOff, sheetW * scale, sheetH * scale);

                ctx.fillStyle = '#38bdf8';
                ctx.font = 'bold 24px Inter';
                ctx.fillText(`SHEET ${parseInt(idx) + 1} - ${sheetData.efficiency}% EFFICIENCY`, 20, yOff - 15);

                sheetData.parts.forEach(p => {
                    if (!p.points) return;

                    ctx.beginPath();
                    p.points.forEach((pt, i) => {
                        let px = pt[0], py = pt[1];
                        // Handle rotation in preview
                        if (p.is_rotated) {
                            const tmp = px; px = py; py = tmp;
                        }
                        const drawX = 20 + (p.x + px) * scale;
                        const drawY = yOff + (p.y + py) * scale;

                        if (i === 0) ctx.moveTo(drawX, drawY);
                        else ctx.lineTo(drawX, drawY);
                    });
                    ctx.closePath();

                    ctx.fillStyle = 'rgba(56, 189, 248, 0.2)';
                    ctx.fill();
                    ctx.strokeStyle = '#38bdf8';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    // Small Label
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Inter';
                    ctx.fillText(p.name, 20 + p.x * scale + 5, yOff + p.y * scale + 15);
                });
            });

            document.getElementById('nesting-stats').innerHTML = `
                <div style="padding: 10px; background: rgba(56,189,248,0.1); border-radius: 8px;">
                    <strong>ALGO:</strong> ${result.algo.split('.').pop()} | 
                    <strong>SHEETS:</strong> ${result.sheet_count}
                </div>
            `;

            const dxfBtn = document.getElementById('download-cnc-dxf');
            dxfBtn.disabled = false;
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f172a);
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 100000);
            camera.position.set(3000, 3000, 3000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('viewport').appendChild(renderer.domElement);
            window.addEventListener('click', onMouseClick, false);
            controls = new OrbitControls(camera, renderer.domElement);


            const light = new THREE.DirectionalLight(0xffffff, 2);
            light.position.set(1, 1, 1);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            scene.add(new THREE.GridHelper(5000, 10, 0x334155, 0x1e293b));
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }


        function onMouseClick(event) {
            // Only raycast if clicking inside viewport
            if (event.clientX < 280) return; // clicking in side panel

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            let clickedIdx = -1;
            for (let i = 0; i < intersects.length; i++) {
                let obj = intersects[i].object;
                if (obj.isMesh && obj.name.startsWith("part_")) {
                    clickedIdx = parseInt(obj.name.split("_")[1]);
                    break; // Just grab the first valid part hit
                }
            }

            selectPart(clickedIdx);
        }

        function selectPart(idx) {
            // Reset previous highlights
            selectedMeshes.forEach(m => {
                if (m.userData.originalMaterial) m.material = m.userData.originalMaterial;
            });
            selectedMeshes = [];

            // Remove UI highlights
            document.querySelectorAll('.part-node').forEach(el => el.classList.remove('highlighted'));

            const panel = document.getElementById('selection-panel');

            if (idx === -1 || !meshMap.has(idx)) {
                panel.style.display = 'none';
                return;
            }

            // Highlight 3D mesh
            const meshes = meshMap.get(idx);
            meshes.forEach(m => {
                const mat = m.material.clone();
                mat.color = selectionColor;
                mat.emissive = new THREE.Color(0x0284c7);
                mat.emissiveIntensity = 0.5;
                m.material = mat;
                selectedMeshes.push(m);
            });

            // Find in manifest for data
            let partData = null;
            manifest.categories.forEach(cat => {
                cat.parts.forEach(p => {
                    if (p.mesh_index === idx) partData = p;
                });
            });

            if (partData) {
                document.getElementById('sel-title').innerText = partData.name.replace("_", " ").toUpperCase();
                document.getElementById('sel-volume').innerText = partData.volume_mm3.toLocaleString();
                document.getElementById('sel-liters').innerText = (partData.volume_mm3 / 1000000).toFixed(2);

                const dims = partData.bbox.size;
                document.getElementById('sel-dims').innerText = `${dims[0]} x ${dims[1]} x ${dims[2]}`;

                panel.style.display = 'block';

                // Highlight UI tree item
                const treeItem = document.getElementById(`tree-part-${idx}`);
                if (treeItem) {
                    treeItem.classList.add('highlighted');
                    treeItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }
        }

        window.selectPart = selectPart;

        function initCube() {
            const container = document.getElementById('view-cube');
            cubeRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            cubeRenderer.setSize(100, 100);
            container.appendChild(cubeRenderer.domElement);

            cubeScene = new THREE.Scene();

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            cubeScene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(2, 5, 5);
            cubeScene.add(dirLight);

            cubeCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
            cubeCamera.position.set(0, 0, 4);

            const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);

            // Create texture canvas for faces
            const createFace = (text) => {
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#cbd5e1';
                ctx.fillRect(0, 0, 128, 128);
                // Thick border
                ctx.strokeStyle = '#334155';
                ctx.lineWidth = 12;
                ctx.strokeRect(0, 0, 128, 128);
                // Inner border
                ctx.strokeStyle = '#94a3b8';
                ctx.lineWidth = 4;
                ctx.strokeRect(6, 6, 116, 116);

                ctx.font = 'bold 26px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#0f172a';
                ctx.fillText(text, 64, 64);

                const texture = new THREE.CanvasTexture(canvas);
                return new THREE.MeshStandardMaterial({ map: texture, roughness: 0.6, metalness: 0.1 });
            };

            const materials = [
                createFace('RIGHT'),    // +x
                createFace('LEFT'),     // -x
                createFace('BACK'),     // +y
                createFace('FRONT'),    // -y
                createFace('TOP'),      // +z
                createFace('BOTTOM')    // -z
            ];

            viewCube = new THREE.Mesh(geometry, materials);

            // Add compass ring underneath
            const ringGeo = new THREE.RingGeometry(1.1, 1.4, 32);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0x475569, side: THREE.DoubleSide, opacity: 0.5, transparent: true });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = -0.9;
            cubeScene.add(ring);

            cubeScene.add(viewCube);

            container.addEventListener('pointerdown', function (event) {
                const rect = container.getBoundingClientRect();
                cubeMouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                cubeMouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                cubeRaycaster.setFromCamera(cubeMouse, cubeCamera);

                const intersects = cubeRaycaster.intersectObject(viewCube);
                if (intersects.length > 0) {
                    // Check exactly where on the cube they clicked (the local 3D point)
                    // The cube is 1.5 x 1.5 x 1.5, centered at 0,0,0
                    const pt = viewCube.worldToLocal(intersects[0].point.clone());

                    // Normalize the click point so it essentially acts as a direction vector
                    // e.g. clicking the corner (+0.75, +0.75, +0.75) gives a diagonal vector
                    const dir = pt.clone().normalize();
                    snapToDirection(dir);
                }
            });
        }

        function snapToDirection(dirVector) {
            if (!model) return;
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());

            // Push the camera out far enough along the chosen vector to see the whole model
            const maxDim = Math.max(size.x, size.y, size.z);
            const dist = maxDim * 1.5;

            controls.target.set(0, 0, 0);

            // To get distinct 45-degree angle snaps instead of arbitrary smooth angles,
            // we round the direction vector components slightly so clicking near a corner snaps perfectly
            const snap = (val) => {
                if (val > 0.3) return 1;
                if (val < -0.3) return -1;
                return 0;
            };

            const snappedDir = new THREE.Vector3(
                snap(dirVector.x),
                snap(dirVector.y),
                snap(dirVector.z)
            ).normalize();

            camera.position.copy(snappedDir).multiplyScalar(dist);
            camera.lookAt(0, 0, 0);
            controls.update();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);

            // Sync view cube
            if (cubeCamera && viewCube) {
                cubeCamera.position.copy(camera.position).normalize().multiplyScalar(4);
                cubeCamera.lookAt(0, 0, 0);
                cubeCamera.up.copy(camera.up);
                cubeRenderer.render(cubeScene, cubeCamera);
            }
        }

        // Start animation loop AFTER everything is defined
        requestAnimationFrame(animate);

    </script>
</body>

</html>